name: üöÄ Release iOS App

on:
  release:
    types: [published]

jobs:
  build-and-deploy-ios:
    name: üèóÔ∏è Build and Deploy iOS App to App Store
    runs-on: macos-15
    steps:
      - name: üìÇ Checkout code
        uses: actions/checkout@v4
      
      - name: üöÄ Cache pub deps
        uses: actions/cache@v4
        with:
          path: ~/.pub-cache
          key: ${{ runner.os }}-pub-${{ hashFiles('**/pubspec.yaml') }}
          restore-keys: ${{ runner.os }}-pub-

      - name: üîß Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.4'

      - name: üì± Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.32.4'
          channel: 'stable'
          
      - name: üì¶ Install dependencies
        run: flutter pub get

      - name: üìã Get version from pubspec
        id: version
        run: |
          VERSION=$(grep '^version:' pubspec.yaml | sed 's/version: //')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: üîß Setup Codemagic CLI
        run: |
          echo "Setting up Codemagic CLI tools..."
          
          # Install using pip with --break-system-packages flag to handle externally managed environment
          pip3 install --break-system-packages codemagic-cli-tools
          
          echo "Verifying installation..."
          app-store-connect --version
          keychain --version
          xcode-project --version
          
          echo "‚úÖ Codemagic CLI tools installation completed successfully"

      - name: üîë Setup iOS Code Signing
        run: |
          echo "Setting up iOS code signing..."
          
          # Create directories for certificates and profiles
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          mkdir -p ~/Library/Developer/Xcode/DerivedData
          
          echo "Decoding and installing distribution certificate..."
          # Decode and install distribution certificate
          echo "${{ secrets.DIS_CERTIFICATE_BASE64 }}" | base64 -d > dist_cert.p12
          
          echo "Creating keychain..."
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security set-keychain-settings -t 3600 -l ~/Library/Keychains/build.keychain
          
          echo "Importing certificate to keychain..."
          security import dist_cert.p12 -k build.keychain -P "${{ secrets.DIS_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
          
          # Enhanced certificate verification
          echo "üîç Enhanced Certificate Verification:"
          echo "Available signing identities:"
          security find-identity -v build.keychain
          
          # Get the exact identity name for signing
          SIGNING_IDENTITY=$(security find-identity -v build.keychain | grep "iPhone Distribution" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          echo "Using signing identity: $SIGNING_IDENTITY"
          
          if [ -z "$SIGNING_IDENTITY" ]; then
            echo "‚ùå No iPhone Distribution certificate found"
            exit 1
          fi
          
          # Extract certificate hash for verification
          CERT_HASH=$(security find-identity -v build.keychain | grep "iPhone Distribution" | head -1 | awk '{print $2}')
          echo "Certificate hash: $CERT_HASH"
          
          echo "Decoding and installing provisioning profile..."
          # Robust: Zeilenumbr√ºche entfernen und base64 dekodieren
          echo "${{ secrets.PROVISIONING_PROFILE }}" | tr -d '\n' | base64 -D > dist_profile.mobileprovision
          cp dist_profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/
          
          echo "Verifying installed profiles..."
          # List installed profiles for verification
          ls -lh dist_profile.mobileprovision
          file dist_profile.mobileprovision
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
          
          # Enhanced provisioning profile verification
          echo "üîç Enhanced Provisioning Profile Verification:"
          echo "Provisioning profile details:"
          security cms -D -i dist_profile.mobileprovision | grep -E "(Name|TeamIdentifier|TeamName|AppIDName|UUID|ExpirationDate)"
          
          # Extract certificate hash from provisioning profile using the working one-liner
          echo "Certificates in provisioning profile:"
          PROFILE_CERT_HASH=$(security cms -D -i dist_profile.mobileprovision | plutil -extract DeveloperCertificates.0 raw -o - - | base64 -D | openssl x509 -inform DER -noout -fingerprint -sha1 | sed 's/SHA1 Fingerprint=//' | tr -d ':')
          echo "Profile certificate hash: $PROFILE_CERT_HASH"
          
          # Verify certificate-profile match
          echo "üîç Verifying Certificate-Profile Match:"
          if [ "$CERT_HASH" = "$PROFILE_CERT_HASH" ]; then
            echo "‚úÖ Certificate hash matches provisioning profile"
          else
            echo "‚ùå Certificate hash mismatch!"
            echo "   Certificate hash: $CERT_HASH"
            echo "   Profile hash: $PROFILE_CERT_HASH"
            echo "   This will cause App Store Connect upload to fail"
            exit 1
          fi
          
          # Verify certificate expiration
          echo "üîç Checking Certificate Expiration:"
          CERT_EXPIRY=$(security find-certificate -c "$SIGNING_IDENTITY" -p build.keychain | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
          echo "Certificate expires: $CERT_EXPIRY"
          
          # Check if certificate is expired
          if [ -n "$CERT_EXPIRY" ]; then
            EXPIRY_EPOCH=$(date -j -f "%b %d %H:%M:%S %Y %Z" "$CERT_EXPIRY" +%s 2>/dev/null)
            CURRENT_EPOCH=$(date +%s)
            if [ "$EXPIRY_EPOCH" -lt "$CURRENT_EPOCH" ]; then
              echo "‚ùå Certificate has expired!"
              exit 1
            else
              echo "‚úÖ Certificate is valid"
            fi
          fi
          
          echo "Code signing setup completed successfully"
          
          # Configure Flutter to use our keychain
          echo "üîß Configuring Flutter to use build keychain..."
          export CODESIGN_KEYCHAIN=build.keychain
          export CODESIGN_KEYCHAIN_PASSWORD=""
          
          # Set keychain as default for codesign
          security default-keychain -s build.keychain
          security list-keychains -s build.keychain
          security unlock-keychain -p "" build.keychain
          
          # Verify Flutter can see the certificates
          echo "üîç Verifying Flutter can access certificates:"
          flutter doctor -v
          
          # Show available signing identities for Flutter
          echo "üîç Available signing identities for Flutter:"
          security find-identity -v build.keychain | grep "iPhone Distribution"

      - name: üì± Build and sign iOS App
        env:
          CODESIGN_KEYCHAIN: build.keychain
          CODESIGN_KEYCHAIN_PASSWORD: ""
          FLUTTER_BUILD_NUMBER: ${{ github.run_number }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
            # Build without code signing first
            echo "üî® Building without code signing..."
            flutter build ios --release --no-codesign --build-number=${{ github.run_number }}
            
            echo "‚úÖ Flutter build completed without code signing"
            
            # Get the exact certificate name from keychain
            echo "üîç Getting exact certificate name..."
            CERT_NAME=$(security find-identity -v build.keychain | grep "iPhone Distribution" | head -1 | sed 's/.*"\(.*\)".*/\1/')
            echo "Using certificate: $CERT_NAME"
            
            # Manually sign the app with our certificate
            echo "üîê Manually signing the app..."
            codesign --force --sign "$CERT_NAME" --keychain build.keychain build/ios/iphoneos/Runner.app
            
            echo "‚úÖ Manual code signing completed"
            
            # Embed the provisioning profile
            echo "üìã Embedding provisioning profile..."
            cp dist_profile.mobileprovision build/ios/iphoneos/Runner.app/embedded.mobileprovision
            
            echo "‚úÖ Provisioning profile embedded"
            
            # Sign all frameworks
            echo "üîê Signing frameworks..."
            find build/ios/iphoneos/Runner.app/Frameworks -name "*.framework" -type d | while read framework; do
              echo "Signing framework: $framework"
              codesign --force --sign "$CERT_NAME" --keychain build.keychain "$framework"
            done
            
            echo "‚úÖ All frameworks signed"

      - name: üîç Verify Built App
        run: |
          echo "üîç Verifying built app..."
          
          # Find the built app
          APP_PATH=$(find build/ios/iphoneos -name "*.app" -type d | head -1)
          echo "App path: $APP_PATH"
          
          if [ ! -d "$APP_PATH" ]; then
            echo "‚ùå Built app not found"
            exit 1
          fi
          
          # Verify code signing
          echo "Verifying code signing..."
          codesign -dv --verbose=4 "$APP_PATH"
          
          # Verify provisioning profile is embedded
          if [ -f "$APP_PATH/embedded.mobileprovision" ]; then
            echo "‚úÖ Provisioning profile embedded successfully"
            ls -la "$APP_PATH/embedded.mobileprovision"
          else
            echo "‚ùå Provisioning profile not embedded"
            exit 1
          fi
          
          # Verify the certificate matches the provisioning profile in the built app
          echo "üîç Final Certificate-Profile Verification:"
          BUILT_CERT_HASH=$(codesign -dv --verbose=4 "$APP_PATH" 2>&1 | grep "Authority=" | head -1 | grep -o '[A-F0-9]\{40\}' || echo "")
          PROFILE_CERT_HASH=$(security cms -D -i "$APP_PATH/embedded.mobileprovision" | grep -A 10 "DeveloperCertificates" | grep -o '[A-F0-9]\{40\}' | head -1)
          
          echo "Built app certificate hash: $BUILT_CERT_HASH"
          echo "Profile certificate hash: $PROFILE_CERT_HASH"
          
          if [ "$BUILT_CERT_HASH" = "$PROFILE_CERT_HASH" ]; then
            echo "‚úÖ Built app certificate matches provisioning profile"
          else
            echo "‚ùå Built app certificate mismatch with provisioning profile"
            echo "   This will cause App Store Connect upload to fail"
            exit 1
          fi
          
          # Verify all frameworks are signed
          echo "üîç Verifying framework signing..."
          find "$APP_PATH/Frameworks" -name "*.framework" -type d | while read framework; do
            echo "Checking framework: $framework"
            codesign -dv "$framework" 2>&1 | grep -q "Authority=" || {
              echo "‚ùå Framework not properly signed: $framework"
              exit 1
            }
          done
          
          echo "‚úÖ All verification checks passed"

      - name: üì¶ Create IPA
        run: |
          # Create payload directory
          mkdir -p Payload
          
          # Find the built app
          APP_PATH=$(find build/ios/iphoneos -name "*.app" -type d | head -1)
          echo "App path: $APP_PATH"
          
          # Copy app to payload
          cp -R "$APP_PATH" Payload/
          
          # Create IPA
          zip -r "dienstplan-${{ github.event.release.tag_name }}-${{ github.run_number }}.ipa" Payload
          
          # Clean up
          rm -rf Payload

      - name: ‚¨ÜÔ∏è Upload IPA to Release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: dienstplan-${{ github.event.release.tag_name }}-${{ github.run_number }}.ipa
          asset_name: dienstplan-${{ github.event.release.tag_name }}-${{ github.run_number }}.ipa
          asset_content_type: application/octet-stream

      - name: üè™ Deploy to App Store Connect
        env:
          APP_STORE_CONNECT_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_KEY_IDENTIFIER: ${{ secrets.APPSTORE_CONNECT_KEY_IDENTIFIER }}
          APP_STORE_APP_ID: ${{ secrets.APP_STORE_APP_ID }}
        run: |
          echo "Starting App Store Connect deployment..."
          
          # Verify Codemagic CLI tools are available
          echo "Checking Codemagic CLI tools installation..."
          which app-store-connect
          app-store-connect --version
          
          # App Store Connect API key is available via environment variable
          echo "App Store Connect API key available via environment variable"
          
          # Verify the IPA file exists
          IPA_FILE="dienstplan-${{ github.event.release.tag_name }}-${{ github.run_number }}.ipa"
          if [ -f "$IPA_FILE" ]; then
            echo "‚úÖ IPA file found: $IPA_FILE"
            ls -la "$IPA_FILE"
          else
            echo "‚ùå IPA file not found: $IPA_FILE"
            ls -la *.ipa || echo "No IPA files found"
            exit 1
          fi
          
          echo "Uploading to App Store Connect..."
          
          # Set environment variables for authentication
          export APP_STORE_CONNECT_ISSUER_ID="$APP_STORE_CONNECT_ISSUER_ID"
          export APP_STORE_CONNECT_KEY_IDENTIFIER="$APP_STORE_CONNECT_KEY_IDENTIFIER"
          export APP_STORE_CONNECT_PRIVATE_KEY="$APP_STORE_CONNECT_PRIVATE_KEY"
          
          echo "Environment variables set for authentication"
          
          # Upload to App Store Connect
          app-store-connect publish \
            --path "$IPA_FILE"
          
          echo "‚úÖ App Store Connect deployment completed"

      - name: üßπ Cleanup
        run: |
          # Remove sensitive files
          rm -f dist_cert.p12
          rm -f dist_profile.mobileprovision
          rm -f "dienstplan-${{ github.event.release.tag_name }}-${{ github.run_number }}.ipa"
          
          # Remove keychain
          security delete-keychain build.keychain 